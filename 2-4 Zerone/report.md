---
header-includes:
    - \usepackage{ctex}
---

# 2-4 Zerone 解题报告

## 原理

将每个 01 串依次插入二叉编码树，并根据以下原则更新每个节点上的胜负情况：

- 叶子节点深度为奇数时 Adam 胜，深度为偶数时 Eve 胜。（深度为奇数时，轮到 Adam ，他的选择只要当前节点相反，下一步的 i 大于当前 01 串的长度，且轮到 Eve，从而 Eve 必败；反之亦然）
- 内部节点如果只有一个孩子，胜负情况同孩子。
- （假设用 0 表示 Adam 胜， 1 表示 Eve 胜）内部节点如果有两个孩子：若深度为奇数，胜负情况为两个孩子的胜负情况取或；若深度为偶数，胜负情况为两个孩子胜负情况取与。（若深度为奇数，下一步轮到 Eve，只要有一个孩子使 Eve 获胜 Eve 就必然选择这条路径，所以取或；反之亦然）

每次插入从叶子向上递归地更新胜负情况，然后返回根节点的胜负情况即可。

## 遇到的问题

最多 $10^6$ 个串，若按一般的方式存储，至多需要 $2^0+2^1+\cdots+2^{19}+45\times 10^6\sim 2^{26}=2^6$M 个节点，若要满足空间限制，每个节点只能占 1B ，这是不现实的。注意到上述最坏情况中，存在大量无分岔的「单链」，可以将其压缩到一个节点中。比如每个节点中最多存长度为 13 的链，则最坏节点个数变为 $2^0+2^1+\cdots+2^{19}+4\times 10^6\sim 2^{23}$，存储一个节点需要的比特数变为 23（左子地址）+23（右子地址）+4（链长）+13（链）+1（胜负情况）=64，正好可以存到一个 64 位整数中。

在插入时，只需将待插入的串和当前节点中存的链进行前缀匹配，将公共前缀保留在当前节点，原有的链去除公共前缀作为一个孩子，待插入的串去除公共前缀作为另一个孩子插入即可。

## 复杂度分析

设最大串长为 $L$。

- 时间复杂度：单次插入为线性递归，$\mathcal{O}(L)$。插入后立即得到胜负。总共 $\mathcal{O}(nL)$。
    
- 空间复杂度：若将压缩存储方式的影响视作一个常数，则根据之前的计算，占用空间为 $\mathcal{O}(n(L-\log{n}))$。事实上，减小的常数与 $L$ 是可比的（$L=64$ ，链长 13），因此压缩存储方式可使 $nL$ 项显著减小。