---
header-includes:
    - \usepackage{ctex}
---

# 3-1 Pokeface 解题报告

## 原理

使用线段树，在每个节点上存储这个节点对应的线段中正面朝上的个数。为节省更新操作的时间，采用懒惰更新策略，即还须在每个节点上存储一个翻转标记。翻转标记为 1 表示这个节点的左右孩子都还欠一次整体翻转（由于翻转两次就抵消了，不用记录欠的次数，只需要一个二值的标记）。

更新时，若待翻转区间覆盖了当前节点的区间，则直接改变当前节点的翻转标签，并把正面朝上的个数变为（区间长度-原来的个数）；否则，先将当前节点的翻转标记传播给两个孩子、清除当前节点的翻转标记，再递归地向下更新。

查询时，若待查询区间覆盖了当前节点的区间，则直接返回当前节点正面朝上的个数；否则，先将当前节点的翻转标记传播给两个孩子、清除当前节点的翻转标记，再递归查询两个孩子，返回二者之和。

## 遇到的问题

- 若不使用懒惰更新，每次更新需要访问所有覆盖到的节点，最坏复杂度为 $\mathcal{O}(n)$，且常数比蛮力更坏，不可行。采用懒惰更新将更新操作优化到 $\mathcal{O}(\log{n})$。
- 最初实现懒惰更新策略时只在更新时向下传播了翻转标记，在查询时没有向下传播，导致答案错误。实际上只要需要访问一个节点的孩子就必须先将其翻转标记向下传播。

## 复杂度分析

- 时间复杂度：更新操作$\mathcal{O}(\log{n})$，查询操作 $\mathcal{O}(\log{n})$，总计 $\mathcal{O}((p+q)\log{n})$。
    
- 空间复杂度：即构建一棵线段树的空间，更新和查询操作都不涉及额外空间。$\mathcal{O}(n)$。