---
header-includes:
    - \usepackage{ctex}
---

# 2-6 Penetration 解题报告

## 原理

维护可持久化线段树，使得：

- 每个叶子节点对应于一个点
- 每个内部节点对应于其两个孩子对应的线段取并
- 每个节点上另外记录：被插入线段树的线段中，能够覆盖这个节点所对应线段、不能覆盖它的父亲所对应线段的线段的数量和满足条件的线段的权重之和
- 保留所有历史版本

题目中求某个节点上权重最小的 $k$ 条线段的权重之和，假设线段按照权重从小到大的顺序插入，即求当插入到这个节点上覆盖了 $k$ 条线段的历史版本下，这 $k$ 条线段的权重之和。覆盖数量和权重之和都可通过从树根到这个节点的路径上记录的数据相累加得到。由于整个插入过程中一点上覆盖的线段数量单调非减，通过二分查找即可确定所需的版本号。

## 遇到的问题

- 若使用最原始的线段树，需要为每个节点维护一个链表，记录被插入的线段中所有能覆盖当前节点但不能覆盖其父亲的线段；在查询时，排序取前 $k$ 个求和。这样在时间、空间上都有浪费，且实现麻烦。
- 注意到只需知道前 $k$ 个权重之和，不用记录每个权重，考虑在对输入排序后使用可持久化线段树。如果为 $m$ 个历史版本维护 $m$ 棵树，空间和时间上显然都不可行。注意到每次插入操作至多改变 $\mathcal{O}(\log{n})$ 的节点的值，对于无需更新的子树，直接指向旧版本中对应位置的子树。

## 复杂度分析

- 时间复杂度：对输入排序 $\mathcal{O}(m\log{m})$。$m$ 次插入操作，每次 $\mathcal{O}(\log{n})$。$n$ 次插入操作，每次 $\mathcal{O}(\log{n})$。共计 $\mathcal{O}(m\log{m}+(m+n)\log{n})$。
    
- 空间复杂度：初始状态下树的体积为 $\mathcal{O}(n)$，每次插入操作新增至多 $\mathcal{O}(\log{n})$ 个节点。共计 $\mathcal{O}(n+m\log{n})$。