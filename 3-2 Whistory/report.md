---
header-includes:
    - \usepackage{ctex}
---

# 3-2 Whistory 解题报告

## 原理

将每个字符串转化为其最小循环表示，再对字符串的最小循环表示进行哈希，记录每类字符串第一次出现的位置即可。

## 遇到的问题

求字符串的最小循环表示。暴力算法需要遍历每个起始点，每次对两个起始点对应的字符串进行比较，最坏为$\mathcal{O}(n^2)$. 

借鉴 KMP 的思路，首先将字符串自己和自己相接作为新的字符串，问题即转化为在 $S[0,2l)$ 中，找出字串 $[0,l),[1,l+1),\cdots,[l-1,2l)$ 中最小的串。用$i,j$分别表示当前已经找到的最小表示位置、当前待比较的位置。若以$i,j$为起始点的字符串部分匹配，则下一轮迭代中，直接将$i$前进到失配位置。如此可保持不变性 $S[i]<S(i,j)$，而每个位置至多被比较 2 次，整体复杂度下降到线性。

## 复杂度分析

- 时间复杂度：对于每个字符串，求最小表示$\mathcal{O}(n)$，查询和更新哈希表期望 $\mathcal{O}(1)$。共 $m$ 个字符串，总体时间复杂度$\mathcal{O}(mn)$。
    
- 空间复杂度：哈希表尺寸 $\mathcal{O}(m)$，每个位置中存储字符串需要 $\mathcal{O}(n)$，总体空间复杂度$\mathcal{O}(mn)$。