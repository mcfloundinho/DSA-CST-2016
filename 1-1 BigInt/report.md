---
header-includes:
    - \usepackage{ctex}
---

# 1-1 BigInt 解题报告

## 原理

使用模拟手算的方法进行高精度乘法. 为降低常数, 将若干个十进制位作为一段, 同时须保证所有中间结果不溢出 `uint64_t` 的范围. 设每段的位数为 $x$, 则有每个被乘数最多有 $n = \lceil \frac{5000}{x} \rceil$ 段. 在模拟手算中, 需要 `uint64_t` 容纳 $n$ 个一对 $10^x$ 位十进制数乘积之和, 从而 $\lceil \frac{5000}{x} \rceil \cdot 10^{2x} < 2^{64}$, 可得 $x \leq 8$. 因此以 8 位为一段.

## 遇到的问题

- 进位的效率问题: 一般在手算乘法时, 所有中间结果都进行进位, 设每个被乘数的位数均为 $n$, 则这样需要 $\mathcal{O}(n^2)$ 的整除和取模运算, 导致时间复杂度偏高. 对算法稍加修改, 先不考虑进位, 完成卷积运算后再统一处理进位, 可以把整除和取模的次数降低到 $\mathcal{O}(n)$ , 提高效率.
- 边界情况的处理: 如果有一个被乘数为 0, 另一个被乘数位数大于 1, 如果通过被乘数位数相加判定乘积位数就会出错, 导致输出多余的 0. 发现答案错误后, 代码中特判了这种边界情况.

## 复杂度分析

- 时间复杂度: 输入的位数和 8 位一段处理后的段数差一常系数, 其区别在复杂度分析时忽略不计, 认为两者都是 $n$. 则开销如下:
    - 输入 (反向遍历字符串): $\mathcal{O}(n)$.
    - 卷积 (二重循环): $\mathcal{O}(n^2)$.
    - 进位: $\mathcal{O}(2n)=\mathcal{O}(n)$.
    - 输出: $\mathcal{O}(n)$.
    
    整体时间复杂度为 $\mathcal{O}(n^2)$.

- 空间复杂度: 需要存储两个被乘数和乘积. 此外除 I/O 缓冲外不再需要其他额外空间. 空间复杂度为 $\mathcal{O}(n)$.