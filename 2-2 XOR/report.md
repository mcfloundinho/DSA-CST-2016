---
header-includes:
    - \usepackage{ctex}
---

# 2-2 XOR 解题报告

## 原理

要使两个数的异或最大，即希望在尽量高的位置出现不同的 bit 。因此，对插入的数按位构建二叉编码树，对于需要异或的数在编码树中由根至叶，用贪心算法，每次尽可能选择与数的当前位相反的子节点，即可得到最大的异或。

## 遇到的问题

- 由于每次需要求一段连续的数，而非某两个数的最大异或和，上述思路不能直接使用。借鉴网上的资料提供的思路（`http://qpswwww.logdown.com/posts/332998-BZOJ-3261`），我进行了如下处理：
    + 先读入所有数，然后从后向前扫描，每次记录当前后缀的异或和，即 $post(k)\triangleq a_k\oplus a_{k+1}\oplus\cdots\oplus a_n$。由于每次只需要在上一次结果的基础上异或一次，这个操作是 $\mathcal{O}(1)$ 的。
    + 每次将后缀异或和插入二叉编码树。
    + 根据异或的性质：
        * $a \oplus b = b \oplus a$
        * $a \oplus (b \oplus c) = (a \oplus b) \oplus c$
        * $a \oplus a = 0$
        
        可知 $post(i)\oplus post(j)=a_i \oplus a_{i+1} \oplus \cdots a_{j-1}\ (i<j)$ ，即通过两个后缀异或和的异或得到中间一段的异或和。亦即每次取最大值即用当前的后缀异或和与编码树中已有的后缀异或和取最大异或。

- 题目中还对每个异或和的长度有限制，因而需要对编码树增加删除接口，去掉最先插入的数。需要进行如下修改：
    + 对每个节点记录父亲。
    + 用一个队列记录插入的叶子节点。
    + 针对同一个数反复插入的情况，对叶子节点记录“重数”。对于重数大于 1 的叶子，删除时将重数自减 1 即可。对于重数等于 1 的叶子，删除时逐层向上删除，直到遇到有两个孩子的节点为止。

## 复杂度分析

（以下将字长 $W=32$ 视作常数）

- 时间复杂度：由于树高固定为 $W$ ，单次插入／删除／求最大异或操作的复杂度都是 $\mathcal{O}(W)=\mathcal{O}(1)$。总体时间复杂度 $\mathcal{O}(N)$。
    
- 空间复杂度：
    + 高度固定的二叉编码树，叶节点至多 $N$，占用空间 $\mathcal{O}(N)$。
    + 记录插入的叶节点的队列，$\mathcal{O}(N)$。
    
    总体空间复杂度 $\mathcal{O}(N)$。